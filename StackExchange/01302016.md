##Original Address: [how-does-a-segmentation-fault-work-under-the-hood](http://unix.stackexchange.com/questions/257598/how-does-a-segmentation-fault-work-under-the-hood)
##How does a Segmentation Fault work under-the-hood?
##Segmentation Fault 是如何工作的？
###Qustion:
I can't seem to find any information on this aside from "the CPU's MMU sends a signal" and "the kernel directs it to the offending program, terminating it".
###问：
我找不到除了“CPU的MMU发送了一个信号”和“内核检测到错误，终止执行以外的答案”。
I assumed that it probably sends the signal to the shell and the shell handles it by terminating the offending process and printing `"Segmentation fault"`. So I tested that assumption by writing an extremely minimal shell I call*`crsh`*(crap shell). This shell does not do anything except take user input and feed it to the system()method.

我猜想是可能是因为程序给shell发送了一个信号，shell接收到这个信号后就终止了当前进程的执行并输出`Segmentation fault`，因此我按这个想法在一个我称作”crsh“（crap shell）的最小化shell中进行了测试。这个shell除了接收用户输入并将其传送给System()之外别无用处。

````c
#include <stdio.h>;
#include <stdlib.h>;

int main(){
    char cmdbuf[1000];while(1){
        printf("Crap Shell&gt; ");
        fgets(cmdbuf,1000, stdin);
        system(cmdbuf);
    }
}
````

So I ran this shell in a bare terminal (without`bash`running underneath). Then I proceeded to run a program that produces a segfault. If my assumptions were correct, this would either a) crash `crsh`, closing the xterm, b) not print`"Segmentation fault"`, or c) both.
````csh
braden@system ~/code/crsh/ $ xterm -e ./crsh
CrapShell>./segfault
Segmentation fault
CrapShell>[still running]
````
Back to square one, I guess. I've just demonstrated that it's not the shell that does this, but the system underneath. How does "Segmentation fault" even get printed? "Who" is doing it? The kernel? Something else? How does the signal and all of its side effects propagate from the hardware to the eventual termination of the program?

####Poster: [Braden Best](http://unix.stackexchange.com/users/54466/braden-best) @ Jan.25th.2016

###Most Voted Answer Posted By [zwol](http://unix.stackexchange.com/users/21167/zwol) on Jan.26th.2016 
The full sequence of events is:

1.A user-space process executes a machine instruction that accesses a page of the address space that is either unmapped (there is no physical RAM there at all) or inaccessible in that fashion (write access to a read-only page, for instance).

2.The CPU suspends execution of the offending process, and transfers control to the kernel with a memory protection exception.

3.The kernel determines that this is due to an unrecoverable error and not, say, a page that needs to be retrieved from the swap space.

4.The kernel sends the offending process a SIGSEGV signal. The default behavior of this signal is to terminate a process that receives it. A program can override that by installing a handler for the signal, in which case something else rather more complicated would happen, but let's assume it has not done this.

5.Therefore, the kernel terminates the offending process, which has all the same effects as calling _exit - open files are closed, memory is deallocated, etc.

6.The kernel notifies the parent process, via another signal (SIGCHLD) and/or via one of the wait family of system calls, that one of its children has exited. In your examples, the parent process is running a shell program, but it doesn't have to be: any process can create children and then wait for them to exit.

7.The notification to the parent process includes information about how the process exited; in this case, that it was terminated due to a SIGSEGV signal.

8.The parent process may, if it wishes, report this information by printing a message. Shell programs almost always do do this.

Your `crsh` doesn't include the code for step 8, but it happens anyway, because `system` runs `/bin/sh` "under the hood".  `crsh` is the grandparent in this scenario; the parent-process notification is fielded by `/bin/sh`, which prints its usual message. Then `/bin/sh` itself exits, since it has nothing more to do, and the C library's implementation of `system` receives that exit notification. You can see that exit notification in your code, by inspecting the return value of `system`; but it won't tell you that the grandchild process died on a segfault, because that was consumed by the intermediate shell process.

